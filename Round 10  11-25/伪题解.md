## Round 10

出题人：王思齐、袁方舟、左骏驰

#### line

先写出一个平方dp，然后搞个单调栈，然后发现是一个类似区间凸包的东西。

可以分治，二进制分组，分块，~~直接for~~

代码写的是带修改二进制分组

#### time map

考虑在往下走的路中and只会0->1，所以变化次数很少。考虑搞一个倍增数组，每次往下走直到and变化。

数列显然可以用线段树维护，但是如果直接倍增的时候线段树维护是三个log过不去。但是我们注意到往下走的时候l或r不变，那么我们可以直接在线段树上二分出这个区间最短的满足and不变的前或后缀，然后再在倍增数组上走就好了。

#### New problem to be configured

大概是一个码码码的题，以下是我的实现细节：

1. 写个函数支持往操作数栈里push一个常数
2. 写一个变量类，变量全放内存里，用的时候取出来。在构造函数里分配内存，支持一些基本的运算和输入输出
3. 考虑如何实现if和while。一个容易想到的实现方法是在开一个 `vector<string>`存代码，把代码全存在当前的 `back()`，对于子结构只需要往 `vector` 末尾加一个新的 `string` ，结束时进行处理并弹出即可
4. if的实现很容易：`if(x) f;` ：x放进栈里，把f的长度push到栈里，`?`，f
5. 考虑写个dowhile：`do(f) while(x>0);` （`assert(x>=0)`）。枚举一个padding：f，若干个空格，`1`，x放进栈里，`0:-`，把(f的长度+padding)push到栈里，`?`。先把剩下的填好，空格的个数容易计算。
6. 接下来就只要实现那些乱七八糟的东西就好了。排序冒泡。强连通分量可以手写栈然后kosaraju或者tarjan。最短路bellmanford，如果次数爆了就少跑几轮，数据很弱。解释器的话只要把它给的那个东西翻译一下，不过似乎卡常数。